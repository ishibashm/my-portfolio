# 実践的デバッグとアーキテクチャ再構築の技術的記録：Next.js + ヘッドレスWordPressにおけるビルドエラーの体系的解決

## 1. 序論：プロジェクトの課題と本ドキュメントの目的

本プロジェクトは、「既存のNext.jsプロジェクトが抱える問題点の解消」という要求から開始された。初期調査の結果、Vercelへのデプロイ時に複数のビルドエラーが発生し、正常なビルドが完了しない状態であることが確認された。

このドキュメントは、発生した一連のビルドエラーを特定し、その根本原因を分析し、最終的に安定したビルドとデプロイを達成するまでの全技術的プロセスを記録するものである。記録された各エラーは、それぞれが独立した事象ではなく、**「フロントエンドのコードベースが持つ期待値」**と、**「バックエンドAPIスキーマ、ビルドツールチェーン、およびフレームワークの仕様という現実」**との間の**「同期不全」**という単一の根本原因から派生した、相互に関連する複数の症状であった。

本記録の目的は、将来のプロジェクトにおいて同様の問題が発生した際に、開発者がエラーログから問題の本質を迅速に特定し、体系的なアプローチによって問題を解決するための実践的な技術資料として機能することにある。

---

## 2. エラー分析と解決の時系列記録

### 2.1. `graphql-codegen` におけるスキーマ取得失敗 (`socket hang up`)

#### 2.1.1. 現象
ビルドプロセスの初期段階、`graphql-codegen` の実行中に以下のエラーが発生し、ビルドが失敗した。

```
[FAILED] Failed to load schema from https://cloud-palette.com/graphql:
[FAILED] socket hang up
```

#### 2.1.2. 技術的分析
このエラーは、`graphql-codegen` が `codegen.ts` に設定された `schema` URL (`https://cloud-palette.com/graphql`) に対してイントロスペクションクエリ（Introspection Query）を送信した際に、TCPレベルで接続が確立できなかった、あるいは確立後にサーバーからの応答がなく接続が切断されたことを示す。原因は、以下のいずれかである可能性が高い。
-   指定されたホスト名が解決できない（DNSの問題）。
-   ホストは存在するが、指定されたポートでサービスがリッスンしていない。
-   ネットワーク経路上（ファイアウォールなど）で接続がブロックされている。
-   サーバー側がリクエストを処理できず、タイムアウトしている。

#### 2.1.3. 解決プロセス
プロジェクトの初期情報として提供された `implementation-plan.md` に記載のIPアドレス `http://35.224.211.72` が、WordPressバックエンドの実際のエンドポイントであると仮定。`codegen.ts` の `schema` プロパティをこのIPアドレスに変更した。この修正は、DNS解決やドメイン関連の問題を排除し、より直接的にバックエンドサーバーと通信することを目的とした。

---

### 2.2. `GraphQL Document Validation failed` - スキーマとクエリの不一致

#### 2.2.1. 現象
スキーマ取得URLの修正後、`graphql-codegen` はスキーマの取得には成功したが、次にドキュメント（ローカルのGraphQLクエリ）の検証フェーズで失敗した。

```
[FAILED] GraphQL Document Validation failed with 8 errors;
[FAILED]   Error 0: Cannot query field "homeFields" on type "Page".
[FAILED]   Error 4: Cannot query field "portfolios" on type "RootQuery".
...
```

#### 2.2.2. 技術的分析
このエラーは、`documents` プロパティで指定されたファイル群（`.ts`, `.tsx`）に含まれるGraphQLクエリが、`schema` プロパティで取得したGraphQLスキーマの定義に違反していることを示す。具体的には、フロントエンドのコードが、バックエンドのスキーマに存在しないフィールド（`homeFields`）や型（`portfolios`）を要求していた。

これは、フロントエンド開発が、バックエンドAPIの現状と同期されないまま進められた結果生じた、典型的な「期待値のズレ」である。`graphql-codegen` の検証機能が、この不整合をビルド時に検出し、エラーとして報告した。

#### 2.2.3. 解決プロセス
この問題を恒久的に解決するには、WordPress側でACF（Advanced Custom Fields）とカスタム投稿タイプを設定し、スキーマを拡張する必要がある。しかし、ビルドを成功させるという短期的な目標を達成するため、**フロントエンドのクエリを、現在のバックエンドのスキーマに存在する標準フィールドのみを使用するようにダウングレードする**という戦略的決定を下した。すべての `.graphql` ファイルから、`homeFields`, `portfolios` などのカスタムフィールドへの参照を削除した。

---

### 2.3. `Module not found` - モジュール解決の失敗

#### 2.3.1. 現象
GraphQLクエリの修正後、今度はNext.jsのビルドプロセス（Webpack/Turbopack）の段階で、モジュール解決エラーが発生した。

```
Failed to compile.
./src/app/blog/[slug]/page.tsx
Module not found: Can't resolve ''components/Templates/Post/PostQuery''
```

#### 2.3.2. 技術的分析
このエラーは、`import` 文で指定されたモジュールを、Next.jsのビルドシステムが見つけられなかったことを示す。この原因は、主に2つの設定不備に起因していた。
1.  **`tsconfig.json` の不備**: パスエイリアス（`@/`）を正しく解決するための `baseUrl` と `paths` の設定が欠落または不正確であった。`paths` は `baseUrl` を基点として解決されるため、`baseUrl` の設定は不可欠である。
2.  **リファクタリングによる不整合**: 開発の過程で、GraphQLクエリの管理方法がコンポーネント併記型から `.graphql` ファイルによる中央集権型に変更されたが、`import` 文が古いパスを参照し続けていた。

#### 2.3.3. 解決プロセス
1.  `tsconfig.json` の `compilerOptions` に `"baseUrl": "."` と `"paths": { "@/*": ["src/*"] }` を追加し、パスエイリアスの解決ルールを明示的に定義した。
2.  エラーが発生したすべてのファイルで `import` 文を見直し、`codegen` が生成した正しい `DocumentNode`（例: `PostBySlugDocument`）を `@/gql/graphql` からインポートするように修正した。
3.  リファクタリングによって不要になった古い `.ts` 形式のクエリファイルをすべて削除し、プロジェクトの整合性を確保した。

---

### 2.4. `Type ... does not satisfy the constraint` - Next.js 15の非同期APIへの不適合

#### 2.4.1. 現象
モジュール解決エラーの解消後、TypeScriptの型チェック段階で新たなエラーが発生した。

```
Type error: Type 'PageProps' does not satisfy the constraint ...
Types of property 'params' are incompatible.
Type '{ slug: string[]; }' is missing the following properties from type 'Promise<any>'
```

#### 2.4.2. 技術的分析
このエラーは、Next.js 15のApp Routerにおける破壊的変更に起因する。パフォーマンス向上のため、`params` や `searchParams` といった、リクエスト時に動的に決定されるページのプロパティが、同期的オブジェクトから**非同期の `Promise` オブジェクト**に変更された。我々のコードの型定義 `type PageProps = { params: { slug: string[] } }` は、この新しい仕様と一致していなかった。フレームワークが期待する `Promise` 型に対し、コードは単純なオブジェクト型を渡そうとしていたため、型エラーが発生した。

#### 2.4.3. 解決プロセス
提供されたドキュメント `docs/Next.jsビルドエラーの解決方法.md` に基づき、以下の修正を影響範囲のすべてのページコンポーネントに適用した。
1.  ページコンポーネントのシグネチャを `async` 関数に変更 (`export default async function Page(...)`)。
2.  `props` の型定義を `Promise` でラップ (`type PageProps = { params: Promise<{ slug: string[] }> }`)。
3.  コンポーネント内で `await` キーワードを使用して `params` の `Promise` を解決し、その値にアクセス (`const resolvedParams = await params;`)。

---

### 2.5. `You're importing a component that needs "next/headers"` - RSCアーキテクチャの制約違反

#### 2.5.1. 現象
`draftMode` を使用する `fetchGraphQL.ts` を、クライアントコンポーネントである `Navigation.tsx` が間接的にインポートしたことで、以下のエラーが発生した。

```
Error: You're importing a component that needs "next/headers". That only works in a Server Component.
```

#### 2.5.2. 技術的分析
`next/headers` からインポートされる `draftMode`, `cookies`, `headers` は、リクエストごとのヘッダー情報にアクセスするためのサーバーサイド専用APIである。React Server Components (RSC) のアーキテクチャでは、これらのAPIをクライアントコンポーネント（`'use client'` ディレクティブを持つコンポーネント）のモジュールグラフに含めることは固く禁じられている。

#### 2.5.3. 解決プロセス
サーバー専用機能とクライアントの依存関係を分離するため、データ取得関数を2つに分割した。
1.  **`fetchGraphQL.ts`**: `draftMode` を使用する、サーバーコンポーネント専用の関数として維持。
2.  **`fetchGraphQL-client.ts`**: `draftMode` への依存を完全に排除した、クライアントコンポーネント専用の新しい関数を作成。
3.  `Navigation.tsx` が、新しく作成した `fetchGraphQL-client.ts` をインポートするように修正し、依存関係の境界を明確にした。

---

### 2.6. インフラ起因のエラー (`401 Unauthorized`, `500 Internal Server Error`, `ECONNREFUSED`)

#### 2.6.1. 現象
コードレベルのエラーをすべて解消した後も、Vercelのビルドプロセス中、特に静的ページ生成（SSG）の段階で、APIアクセスに失敗するエラーが続発した。
-   `401 Unauthorized` / `500 Internal Server Error`: VercelのDeployment Protectionが、ビルドサーバーからプロキシURL (`/api/graphql`) への内部アクセスをブロックし、認証ページ（HTML）やエラーページを返していた。
-   `connect ECONNREFUSED 127.0.0.1:3000`: `codegen.ts` が `localhost:3000` のプロキシにアクセスしようとしたが、Vercelのビルド環境では開発サーバーが起動していないため、接続を拒否された。

#### 2.6.2. 技術的分析
これらのエラーは、**ローカル開発環境とVercelのビルド環境との間の環境差異**が原因である。
-   **プロキシの問題**: `next.config.js` のリライト機能は、クライアントサイドのCORSエラー回避には有効だが、サーバーサイドのビルドプロセス（SSG, `codegen`）では、Next.jsサーバー自体が起動していないため機能しない。
-   **認証の問題**: VercelのDeployment Protectionは、外部からのアクセスだけでなく、ビルドプロセス中の内部的な `fetch` リクエストも対象とすることがある。

#### 2.6.3. 解決プロセス
環境差異を吸収するため、データ取得のエンドポイントを動的に切り替えるロジックを導入した。
1.  **`fetchGraphQL.ts` の修正**: `typeof window === 'undefined'` という判定を用い、サーバーサイド（ビルド時）ではWordPressのIPアドレスを直接参照し、クライアントサイド（ブラウザ）ではプロキシパスを参照するようにした。
2.  **`codegen.ts` の修正**: `process.env.NEXT_PUBLIC_WORDPRESS_API_URL` が存在すればそれ（Vercel環境）を、存在しなければ `localhost`（ローカル環境）を参照するように修正しようとしたが、最終的に、認証の壁を確実に越えるため、**WordPressのIPアドレスを直接ハードコードする**という最も確実な方法に落ち着いた。

---

### 2.7. `GraphQL Request must include ... "query"` - `DocumentNode` のシリアライズエラー

#### 2.7.1. 現象
インフラの問題を解決した後、APIから「クエリが含まれていない」というエラーが返された。

#### 2.7.2. 技術的分析
`graphql-codegen` が生成する `...Document` は、GraphQLクエリの抽象構文木（AST）を表現する `DocumentNode` 型のオブジェクトである。これを `fetch` APIの `body` で `JSON.stringify` する際に、クエリ本文を正しく文字列としてシリアライズできていなかった。`query.loc.source.body` のようなプロパティアクセスは不安定であり、`undefined` を返していた。

#### 2.7.3. 解決プロセス
GraphQLの公式ライブラリである `graphql` パッケージに含まれる `print` 関数を導入した。`print` 関数は、`DocumentNode` オブジェクトを受け取り、それを標準的なGraphQLクエリ文字列に変換する責務を持つ。`fetchGraphQL.ts` と `fetchGraphQL-client.ts` の両方で、`body` を作成する際に `print(query)` を使用するように修正し、問題を解決した。

---

## 3. 結論：アーキテクチャの同期と安定化

この一連のデバッグプロセスは、単なるエラー修正の連続ではなかった。それは、**プロジェクトの各構成要素（フロントエンドコード、バックエンドAPI、ビルドツール、デプロイ環境、フレームワーク仕様）の間に存在する「同期不全」を特定し、修正し、全体として一貫性のあるアーキテクチャへと再構築する**プロセスであった。

最終的に、以下のアーキテクチャ原則を確立することで、プロジェクトは安定した状態に到達した。

1.  **信頼できる唯一の情報源 (Single Source of Truth) の原則**: バックエンドのGraphQLスキーマを絶対的な正義とし、フロントエンドは `graphql-codegen` を通じてそれに追従する。
2.  **関心の分離 (Separation of Concerns)**: GraphQLクエリを `.graphql` ファイルとして中央集権的に管理し、コンポーネントの責務をUIのレンダリングに集中させた。
3.  **環境差異の吸収**: サーバーサイドとクライアントサイド、ローカル環境とVercel環境の違いを、データ取得関数や設定ファイルの中で動的に処理するロジックを導入した。
4.  **フレームワークへの準拠**: Next.js 15の非同期APIやRSCのアーキテクチャ制約を正しく理解し、コードを適合させた。

この経験は、現代のWeb開発において、コードを書くスキルと同等に、ツールチェーンとインフラストラクチャを理解し、設定する能力が重要であることを明確に示している。